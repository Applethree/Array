充分利用数组有序的性质，用两个指针i和j分别指向a和b，比较a[i]和b[j]，根据比较结果移动指针，则有如下三种情况
1. a[i] < b[j]，则i增加1，继续比较
2. a[i] == b[j]，则i和j皆加1，继续比较
3. a[i] < b[j]，则j加1，继续比较
重复以上过程直到i或j到达数组末尾。

void FindCommon(int* a, int* b, int n)
{
    int i = 0;
    int j = 0 ;

    while (i < n && j < n)
    {
        if (a[i] < b[j])
            ++i ;
        else if(a[i] == b[j])
        {
            cout << a[i] << endl ;
            ++i ;
            ++j ;
        }
        else// a[i] > b[j]
            ++j ;
    }
}

这到题还有其他的解法，比如对于a中任意一个元素，在b中对其进行Binary Search，因为a中有n个元素，
而在b中进行Binary Search需要logn。所以找出全部相同元素的时间复杂度是O(nlogn)。
另外，上面的方法，只要b有序即可，a是否有序无所谓，因为我们只是在b中做Binary Search。如果a也有序的话，
那么再用上面的方法就有点慢了，因为如果a中某个元素在b中的位置是k的话，那么a中下一个元素在b中的位置一定位于k的右侧，
所以本次的搜索空间可以根据上次的搜索结果缩小，而不是仍然在整个b中搜索。也即如果a和b都有序的话，代码可以做如下修改，
记录上次搜索时b中元素的位置，作为下一次搜索的起始点。
